/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package algo;

import java.util.Scanner;


/**
 *
 * @author rockiericker
 */
public class Des {
   	private static final byte[] IP = { 
		58, 50, 42, 34, 26, 18, 10, 2,
		60, 52, 44, 36, 28, 20, 12, 4,
		62, 54, 46, 38, 30, 22, 14, 6,
		64, 56, 48, 40, 32, 24, 16, 8,
		57, 49, 41, 33, 25, 17, 9,  1,
		59, 51, 43, 35, 27, 19, 11, 3,
		61, 53, 45, 37, 29, 21, 13, 5,
		63, 55, 47, 39, 31, 23, 15, 7
	};
	
	
	private static final byte[] PC1 = {
		57, 49, 41, 33, 25, 17, 9,
		1,  58, 50, 42, 34, 26, 18,
		10, 2,  59, 51, 43, 35, 27,
		19, 11, 3,  60, 52, 44, 36,
		63, 55, 47, 39, 31, 23, 15,
		7,  62, 54, 46, 38, 30, 22,
		14, 6,  61, 53, 45, 37, 29,
		21, 13, 5,  28, 20, 12, 4
	};
	
	
	private static final byte[] PC2 = {
		14, 17, 11, 24, 1,  5,
		3,  28, 15, 6,  21, 10,
		23, 19, 12, 4,  26, 8,
		16, 7,  27, 20, 13, 2,
		41, 52, 31, 37, 47, 55,
		30, 40, 51, 45, 33, 48,
		44, 49, 39, 56, 34, 53,
		46, 42, 50, 36, 29, 32
	};
	
	
	private static final byte[] rotations = {
		1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
	};
	

	private static final byte[] E = {
		32, 1,  2,  3,  4,  5,
		4,  5,  6,  7,  8,  9,
		8,  9,  10, 11, 12, 13,
		12, 13, 14, 15, 16, 17,
		16, 17, 18, 19, 20, 21,
		20, 21, 22, 23, 24, 25,
		24, 25, 26, 27, 28, 29,
		28, 29, 30, 31, 32, 1
	};
	
	// S-boxes (i.e. Substitution boxes)
	private static final byte[][] S = { {
		14, 4,  13, 1,  2,  15, 11, 8,  3,  10, 6,  12, 5,  9,  0,  7,
		0,  15, 7,  4,  14, 2,  13, 1,  10, 6,  12, 11, 9,  5,  3,  8,
		4,  1,  14, 8,  13, 6,  2,  11, 15, 12, 9,  7,  3,  10, 5,  0,
		15, 12, 8,  2,  4,  9,  1,  7,  5,  11, 3,  14, 10, 0,  6,  13
	}, {
		15, 1,  8,  14, 6,  11, 3,  4,  9,  7,  2,  13, 12, 0,  5,  10,
		3,  13, 4,  7,  15, 2,  8,  14, 12, 0,  1,  10, 6,  9,  11, 5,
		0,  14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3,  2,  15,
		13, 8,  10, 1,  3,  15, 4,  2,  11, 6,  7,  12, 0,  5,  14, 9
	}, {
		10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,
		13, 7,  0,  9,  3,  4,  6,  10, 2,  8,  5,  14, 12, 11, 15, 1,
		13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,
		1,  10, 13, 0,  6,  9,  8,  7,  4,  15, 14, 3,  11, 5,  2,  12
	}, {
		7,  13, 14, 3,  0,  6,  9,  10, 1,  2,  8,  5,  11, 12, 4,  15,
		13, 8,  11, 5,  6,  15, 0,  3,  4,  7,  2,  12, 1,  10, 14, 9,
		10, 6,  9,  0,  12, 11, 7,  13, 15, 1,  3,  14, 5,  2,  8,  4,
		3,  15, 0,  6,  10, 1,  13, 8,  9,  4,  5,  11, 12, 7,  2,  14
	}, {
		2,  12, 4,  1,  7,  10, 11, 6,  8,  5,  3,  15, 13, 0,  14, 9,
		14, 11, 2,  12, 4,  7,  13, 1,  5,  0,  15, 10, 3,  9,  8,  6,
		4,  2,  1,  11, 10, 13, 7,  8,  15, 9,  12, 5,  6,  3,  0,  14,
		11, 8,  12, 7,  1,  14, 2,  13, 6,  15, 0,  9,  10, 4,  5,  3
	}, {
		12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3,  4,  14, 7,  5,  11,
		10, 15, 4,  2,  7,  12, 9,  5,  6,  1,  13, 14, 0,  11, 3,  8,
		9,  14, 15, 5,  2,  8,  12, 3,  7,  0,  4,  10, 1,  13, 11, 6,
		4,  3,  2,  12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8,  13
	}, {
		4,  11, 2,  14, 15, 0,  8,  13, 3,  12, 9,  7,  5,  10, 6,  1,
		13, 0,  11, 7,  4,  9,  1,  10, 14, 3,  5,  12, 2,  15, 8,  6,
		1,  4,  11, 13, 12, 3,  7,  14, 10, 15, 6,  8,  0,  5,  9,  2,
		6,  11, 13, 8,  1,  4,  10, 7,  9,  5,  0,  15, 14, 2,  3,  12
	}, {
		13, 2,  8,  4,  6,  15, 11, 1,  10, 9,  3,  14, 5,  0,  12, 7,
		1,  15, 13, 8,  10, 3,  7,  4,  12, 5,  6,  11, 0,  14, 9,  2,
		7,  11, 4,  1,  9,  12, 14, 2,  0,  6,  10, 13, 15, 3,  5,  8,
		2,  1,  14, 7,  4,  10, 8,  13, 15, 12, 9,  0,  3,  5,  6,  11
	} };
	
	
	private static final byte[] P = {
		16, 7,  20, 21,
		29, 12, 28, 17,
		1,  15, 23, 26,
		5,  18, 31, 10,
		2,  8,  24, 14,
		32, 27, 3,  9,
		19, 13, 30, 6,
		22, 11, 4,  25
	};
	
	
	private static final byte[] FP = {
		40, 8, 48, 16, 56, 24, 64, 32,
		39, 7, 47, 15, 55, 23, 63, 31,
		38, 6, 46, 14, 54, 22, 62, 30,
		37, 5, 45, 13, 53, 21, 61, 29,
		36, 4, 44, 12, 52, 20, 60, 28,
		35, 3, 43, 11, 51, 19, 59, 27,
		34, 2, 42, 10, 50, 18, 58, 26,
		33, 1, 41, 9, 49, 17, 57, 25
	};
	

	private static int[] C = new int[28];
	private static int[] D = new int[28];
	
	private static int[][] subkey = new int[16][48];
	
	public static void main(String args[]) {
		System.out.println("Enter the input as a 16 character hexadecimal value:");
		String input = new Scanner(System.in).nextLine();
		int inputBits[] = new int[64];
	
		for(int i=0 ; i < 16 ; i++) {
		
			String s = Integer.toBinaryString(Integer.parseInt(input.charAt(i) + "", 16));
			
			while(s.length() < 4) {
				s = "0" + s;
			}
			
			for(int j=0 ; j < 4 ; j++) {
				inputBits[(4*i)+j] = Integer.parseInt(s.charAt(j) + "");
			}
		}
		
	
		System.out.println("Enter the key as a 16 character hexadecimal value:");
		String key = new Scanner(System.in).nextLine();
		int keyBits[] = new int[64];
		for(int i=0 ; i < 16 ; i++) {
			String s = Integer.toBinaryString(Integer.parseInt(key.charAt(i) + "", 16));
			while(s.length() < 4) {
				s = "0" + s;
			}
			for(int j=0 ; j < 4 ; j++) {
				keyBits[(4*i)+j] = Integer.parseInt(s.charAt(j) + "");
			}
		}
		
		
		System.out.println("\n+++ ENCRYPTION +++");
		int outputBits[] = permute(inputBits, keyBits, false);
		System.out.println("\n+++ DECRYPTION +++");
		permute(outputBits, keyBits, true);
	}
	
	private static int[] permute(int[] inputBits, int[] keyBits, boolean isDecrypt) {
		
		
		int newBits[] = new int[inputBits.length];
		for(int i=0 ; i < inputBits.length ; i++) {
			newBits[i] = inputBits[IP[i]-1];
		}
		
	
		int L[] = new int[32];
		int R[] = new int[32];
		int i;
		
		// Permuted Choice 1 is done here
		for(i=0 ; i < 28 ; i++) {
			C[i] = keyBits[PC1[i]-1];
		}
		for( ; i < 56 ; i++) {
			D[i-28] = keyBits[PC1[i]-1];
		}
		
		// After PC1 the first L and R are ready to be used and hence looping
		// can start once L and R are initialized
		System.arraycopy(newBits, 0, L, 0, 32);
		System.arraycopy(newBits, 32, R, 0, 32);
		System.out.print("\nL0 = ");
		displayBits(L);
		System.out.print("R0 = ");
		displayBits(R);
		for(int n=0 ; n < 16 ; n++) {
			System.out.println("\n-------------");
			System.out.println("Round " + (n+1) + ":");
		
			int newR[] = new int[0];
			if(isDecrypt) {
				newR = fiestel(R, subkey[15-n]);
				System.out.print("Round key = ");
				displayBits(subkey[15-n]);
			} else {
				newR = fiestel(R, KS(n, keyBits));
				System.out.print("Round key = ");
				displayBits(subkey[n]);
			}
		
			int newL[] = xor(L, newR);
			L = R;
			R = newL;
			System.out.print("L = ");
			displayBits(L);
			System.out.print("R = ");
			displayBits(R);
		}
		
	
		int output[] = new int[64];
		System.arraycopy(R, 0, output, 0, 32);
		System.arraycopy(L, 0, output, 32, 32);
		int finalOutput[] = new int[64];
	
		for(i=0 ; i < 64 ; i++) {
			finalOutput[i] = output[FP[i]-1];
		}
		
	
		String hex = new String();
		for(i=0 ; i < 16 ; i++) {
			String bin = new String();
			for(int j=0 ; j < 4 ; j++) {
				bin += finalOutput[(4*i)+j];
			}
			int decimal = Integer.parseInt(bin, 2);
			hex += Integer.toHexString(decimal);
		}
		if(isDecrypt) {
			System.out.print("Decrypted text: ");
		
		} else {
			System.out.print("Encrypted text: ");
		}
		System.out.println(hex.toUpperCase());
		return finalOutput;
	}
	
	private static int[] KS(int round, int[] key) {
	
		int C1[] = new int[28];
		int D1[] = new int[28];
		
		
		int rotationTimes = (int) rotations[round];
	
		C1 = leftShift(C, rotationTimes);
		D1 = leftShift(D, rotationTimes);
	
		int CnDn[] = new int[56];
		System.arraycopy(C1, 0, CnDn, 0, 28);
		System.arraycopy(D1, 0, CnDn, 28, 28);
	
		int Kn[] = new int[48];
		for(int i=0 ; i < Kn.length ; i++) {
			Kn[i] = CnDn[PC2[i]-1];
		}
		
		// Now we store C1 and D1 in C and D respectively, thus becoming the
		// old C and D for the next round. Subkey is stored and returned.
		subkey[round] = Kn;
		C = C1;
		D = D1;
		return Kn;
	}
	
	private static int[] fiestel(int[] R, int[] roundKey) {
		// Method to implement Fiestel function.
		// First the 32 bits of the R array are expanded using E table.
		int expandedR[] = new int[48];
		for(int i=0 ; i < 48 ; i++) {
			expandedR[i] = R[E[i]-1];
		}
		// We xor the expanded R and the generated round key
		int temp[] = xor(expandedR, roundKey);
		// The S boxes are then applied to this xor result and this is the
		// output of the Fiestel function.
		int output[] = sBlock(temp);
		return output;
	}
	
	private static int[] xor(int[] a, int[] b) {
		// Simple xor function on two int arrays
		int answer[] = new int[a.length];
		for(int i=0 ; i < a.length ; i++) {
			answer[i] = a[i]^b[i];
		}
		return answer;
	}
	
	private static int[] sBlock(int[] bits) {
		// S-boxes are applied in this method.
		int output[] = new int[32];
		// We know that input will be of 32 bits, hence we will loop 32/4 = 8
		// times (divided by 4 as we will take 4 bits of input at each
		// iteration).
		for(int i=0 ; i < 8 ; i++) {
			// S-box requires a row and a column, which is found from the
			// input bits. The first and 6th bit of the current iteration
			// (i.e. bits 0 and 5) gives the row bits.
			int row[] = new int [2];
			row[0] = bits[6*i];
			row[1] = bits[(6*i)+5];
			String sRow = row[0] + "" + row[1];
			// Similarly column bits are found, which are the 4 bits between
			// the two row bits (i.e. bits 1,2,3,4)
			int column[] = new int[4];
			column[0] = bits[(6*i)+1];
			column[1] = bits[(6*i)+2];
			column[2] = bits[(6*i)+3];
			column[3] = bits[(6*i)+4];
			String sColumn = column[0] +""+ column[1] +""+ column[2] +""+ column[3];
			// Converting binary into decimal value, to be given into the
			// array as input
			int iRow = Integer.parseInt(sRow, 2);
			int iColumn = Integer.parseInt(sColumn, 2);
			int x = S[i][(iRow*16) + iColumn];
			// We get decimal value of the S-box here, but we need to convert
			// it into binary:
			String s = Integer.toBinaryString(x);
			// Padding is required since Java returns a decimal '5' as '111' in
			// binary, when we require '0111'.
			while(s.length() < 4) {
				s = "0" + s;
			}
			// The binary bits are appended to the output
			for(int j=0 ; j < 4 ; j++) {
				output[(i*4) + j] = Integer.parseInt(s.charAt(j) + "");
			}
		}
		
		int finalOutput[] = new int[32];
		for(int i=0 ; i < 32 ; i++) {
			finalOutput[i] = output[P[i]-1];
		}
		return finalOutput;
	}
	
	private static int[] leftShift(int[] bits, int n) {
		
		int answer[] = new int[bits.length];
		System.arraycopy(bits, 0, answer, 0, bits.length);
		for(int i=0 ; i < n ; i++) {
			int temp = answer[0];
			for(int j=0 ; j < bits.length-1 ; j++) {
				answer[j] = answer[j+1];
			}
			answer[bits.length-1] = temp;
		}
		return answer;
	}
	
	private static void displayBits(int[] bits) {
		// Method to display int array bits as a hexadecimal string.
		for(int i=0 ; i < bits.length ; i+=4) {
			String output = new String();
			for(int j=0 ; j < 4 ; j++) {
				output += bits[i+j];
			}
			System.out.print(Integer.toHexString(Integer.parseInt(output, 2)));
		}
		System.out.println();
	} 
   public String deskrip(String textToDeskrip, String Key,javax.swing.JProgressBar persenProgessBar){
        String deskrip = "";
        
        int persen =0;
        int round = 0, maxRound = 10;
        int[][][] state = inverseStates(textToDeskrip.toCharArray());
        int[][] Password = keyExpansion(4, Key);
        round = maxRound-2; 
        state = Key(state, Password, round+1); 
        state = Shift(state);
        state = Sub(state);
        for(; round >= 0; round--){
           persen++; 
           state = Key(state, Password, round);
           Mix(state);
           state = Shift(state);  
           state = Sub(state);
            double totalPersen= ((double)persen/(double)(maxRound-2))*25.0;
          if(persenProgessBar!=null){
          persenProgessBar.setString(Double.toString((int)totalPersen+50.0)+"%");
          persenProgessBar.setValue(((int)totalPersen)+50);}
        }
        state = Key(state, Password, 0);
        persen =0;
        for(int i=0; i < state.length; i++){
            persen++; 
            for(int j=0; j < state[i].length; j++){
                for(int k=0; k < state[i][j].length; k++){
                    if(state[i][j][k] != 0)
                    deskrip += (char)state[i][j][k];
                    double totalPersen= ((double)persen/(double) state.length)*25.0;
          if(persenProgessBar!=null){
          persenProgessBar.setString(Double.toString((int)totalPersen+75.0)+"%");
          persenProgessBar.setValue(((int)totalPersen)+75);}
                }
            }
        }
        return deskrip;
    } 
    
    
 
  public String enkrip(String textToEnkrip, String Key,javax.swing.JProgressBar persenProgessBar){
      int persen =0;
        String enkrip = "";
        int round = 0, maxRound = 10;
        int[][][] state = states(textToEnkrip.toCharArray());
        int[][] Password = keyExpansion(4, Key);
       
        state = Key(state, Password, round);
    
        for(; round < maxRound-1; round++){
          persen++;  
          state = subBytes(state);
          state = shiftRow(state); 
          mixColumn(state);
          
          state = Key(state, Password, round);
          double totalPersen= ((double)persen/(double)(maxRound-1))*30.0;
          if(persenProgessBar!=null){
          persenProgessBar.setString(Double.toString((int)totalPersen+20.0)+"%");
          persenProgessBar.setValue(((int)totalPersen)+20);}
        }
        state = subBytes(state); 
        state = shiftRow(state);
        state = Key(state, Password, round);
        persen =0;
        for(int i=0; i < state.length; i++){
             persen++; 
            for(int j=0; j < state[i].length; j++){
                for(int k=0; k < state[i][j].length; k++){
                   
                    enkrip += Integer.toHexString(state[i][j][k]).length() < 2 ?
                              "0"+Integer.toHexString(state[i][j][k]): Integer.toHexString(state[i][j][k]);
                    double totalPersen= ((double)persen/(double)state.length)*30.0;
                    if(persenProgessBar!=null){
          persenProgessBar.setString(Double.toString((int)totalPersen+50.0)+"%");
          persenProgessBar.setValue(((int)totalPersen)+50);}
                }
            }
        }
        
        return enkrip;
    }
   
   
   
   
   
   
   
  
   private final byte[][] matrix = 
   {
   {0x02, 0x03, 0x01, 0x01},
   {0x01, 0x02, 0x03, 0x01},
   {0x01, 0x01, 0x02, 0x03},
   {0x03, 0x01, 0x01, 0x02}
   };
   private final byte[][] matrix1 = 
   {
   {0x0E, 0x0B, 0x0D, 0x09},
   {0x09, 0x0E, 0x0B, 0x0D},
   {0x0D, 0x09, 0x0E, 0x0B},
   {0x0B, 0x0D, 0x09, 0x0E}
   };

    private int[][][] states(char[] plainText)
    {
        int length = plainText.length;
        int jmlState = 
                ((length % 16) == length ? 1 : 
                (length % 16) == 0 ? (length / 16) : 
                (length / 16) + 1);
        int states[][][] = new int[jmlState][4][4];
        
        int count = 0;
        
        for(int i=0; i < jmlState; i++){
            for(int j=0; j < 4; j++){
                for(int k=0; k < 4; k++){
                    try{
                  
                    states[i][j][k] = (int)plainText[count];
                    count++;
                    }catch(Exception exc){
                        
                    }
                }
            }
        }
        
        return states;
    }
   

    private int[][][] subBytes(int[][][] initialStates){
        int[][][] states = initialStates;
        
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                for(int k=0; k < states[i][j].length; k++){
                    String hexa = Integer.toHexString(states[i][j][k]);
                   
                    try{
                    states[i][j][k] = getsbox()
                            [Integer.parseInt(hexa.substring(0, 1), 16)]
                            [Integer.parseInt(hexa.substring(1, 2), 16)];
                    }catch(Exception exc){
                    states[i][j][k] = getsbox()
                           [0]
                           [Integer.parseInt(hexa.substring(0, 1), 16)];    
                    }
                    
               }
            }
        }
        
        
        return states;
    }

    private int[][][] shiftRow(int[][][] subtitutedStates){
        int[][][] states = subtitutedStates;
        
        for(int i=0; i < states.length; i++){
            for(int j=1; j < states[i].length; j++){
                for(int k=0; k < j; k++){
                   shiftArray(states[i][j]);
               
                }
            }
        }
        return states;
    }
    
    private void shiftArray(int[] arr){
        int firstArray = arr[0];
        for(int i=0; i < arr.length-1; i++){
            int temp = arr[i];
            arr[i] = arr[i+1];
        }
        arr[arr.length-1] = firstArray;
    } 

    
    //Mix Column Untuk Enkripsi
    private void mixColumn(int[][][] ShiftedState){
       multiplyMatrix(ShiftedState);
    }

    

    private void multiplyMatrix(int[][][] states){
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                
                //Metode RC 4 membuat temprory swaping sebelum dilakukan XOR
                int temp0 = states[i][0][j],
                    temp1 = states[i][1][j],
                    temp2 = states[i][2][j],
                    temp3 = states[i][3][j];
                for(int k=0; k < 4; k++){
                       
                       states[i][k][j] = 
                       Result(temp0, matrix[k][0]) ^//operator xor 
                       Result(temp1, matrix[k][1]) ^//operator xor 
                       Result(temp2, matrix[k][2]) ^//operator xor 
                       Result(temp3, matrix[k][3]); 
                   
                }
                
            }
        }
    }
    
    
    private int[][][] Key(int[][][] statesAfterMixColumns, 
            
                                   int[][] roundKey, int round){
        int[][][] states = statesAfterMixColumns;
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                for(int k=0; k < states[i][j].length; k++){
                    states[i][j][k] = states[i][j][k] ^ roundKey[round == 0 ? j :(4 * round)+j][k];
                }
            }
        } 
        
        return states;
    }
    
    private int[][] keyExpansion(int NkVal, String Password){
        final int Nb = 4, 
                  Nk = NkVal, 
                  Nr = Nk+6,
                  ExKeySize = Nb * (Nr + 1);
        char[] passArr = Password.toCharArray();
        
        int[][] expandedKey = new int[ExKeySize][4];
        int count = 0;
        for(int i=0; i < Nk; i++){
            for(int j=0; j < expandedKey[i].length; j++)
            {   
                try{
                expandedKey[i][j] = (int)passArr[count]; 
                }catch(Exception exc){
                expandedKey[i][j] = count;    
                }
                count++;
            }
        }
        
        for(int i=Nk; i < ExKeySize; i++){
            int[] rowTemp = expandedKey[i-1];
            int[] rotatedRow = rotateWords(rowTemp);
            for(int j=0; j < expandedKey[i].length; j++){
               int temp = expandedKey[i-1][j]; 
               if(i % Nk == 0)
                 temp = subWord(rotatedRow[j]) ^ getRCon()[i / Nk];
               else if(Nk == 8 && i % Nk == 4)
                 temp = subWord(temp);
               expandedKey[i][j] = expandedKey[i-Nk][j] ^ temp;
               
            }
        }        
        
        return expandedKey;
    }
    
    private int[] rotateWords(int[] arr){
        int[] arrToRotate = arr;
        int firstArray = arrToRotate[0];
        for(int i=0; i < arrToRotate.length-1; i++){
            arrToRotate[i] = arrToRotate[i+1];
        }
        arrToRotate[arrToRotate.length-1] = firstArray;
        return arrToRotate;
    }
           
    private int subWord(int state){
        int result = state;
        String hexa = Integer.toHexString(result);
        try{
            result = getsbox()
                    [Integer.parseInt(hexa.substring(0, 1), 16)]
                    [Integer.parseInt(hexa.substring(1, 2), 16)];
        }catch(Exception exc){
            result = getsbox()
                    [0]
                    [Integer.parseInt(hexa.substring(0, 1), 16)];
        }
         return result;        
                
    }
    

    private int[][][] inverseStates(char[] enkripText)
    {
        int length = enkripText.length;
        String combinedHexa = "";
        
        int jmlState = 
                (((length/2) % 16) == (length/2) ? 1 : 
                ((length/2) % 16) == 0 ? ((length/2) / 16) : 
                ((length/2) / 16) + 1);
        int states[][][] = new int[jmlState][4][4];
        int count = 0;      
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                for(int k=0; k < states[i][j].length; k++){
                    try{
                    combinedHexa = ""+enkripText[count]+enkripText[count+1];
                    }catch(Exception exc){
                    combinedHexa = "00";
                    }
                    states[i][j][k] = Integer.parseInt(combinedHexa, 16);
                    count += 2;
                }
            }
        }   
           
           
        
   
        return states;
    }
    

    private int[][][] Shift(int[][][] stateToShift){
        int[][][] states = stateToShift;
        
        for(int i=0; i < states.length; i++){
            for(int j=1; j < states[i].length; j++){
                for(int k=0; k < j; k++){
                   InverseShiftArray(states[i][j]);
                }
            }
        }
        return states;
    }
    
    private int[][][] Sub(int[][][] shiftedState){
        int[][][] states = shiftedState;
        
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                for(int k=0; k < states[i][j].length; k++){
                    String hexa = Integer.toHexString(states[i][j][k]);
                   
                    try{
                    states[i][j][k] = getInvsbox()
                            [Integer.parseInt(hexa.substring(0, 1), 16)]
                            [Integer.parseInt(hexa.substring(1, 2), 16)];
                    }catch(Exception exc){
                    states[i][j][k] = getInvsbox()
                           [0]
                           [Integer.parseInt(hexa.substring(0, 1), 16)];    
                    }
                    
               }
            }
        }
        
        
        return states;
    }
    private void Mix(int[][][] ShiftedStates){
        Multiply(ShiftedStates);
    }
    
    
    
    private void Multiply(int[][][] states){
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                //metode RC4
                //proses swap ...penukaran state
                //menyimpan state pada temprory sebelum dilakukan XOR(Metode Swaping dengan XOR)
                int temp0 = states[i][0][j],
                    temp1 = states[i][1][j],
                    temp2 = states[i][2][j],
                    temp3 = states[i][3][j];
                for(int k=0; k < 4; k++){
                   states[i][k][j] = 
                           //proses XOR dengan matrik berisi bilangan hexa
                       Result(temp0, matrix1[k][0]) ^ 
                       Result(temp1, matrix1[k][1]) ^ 
                       Result(temp2, matrix1[k][2]) ^ 
                       Result(temp3, matrix1[k][3]); 
                   
                }
                //end proses swap
                
            }
        }
    }
        
     private void InverseShiftArray(int[] arr){
        int lastArray = arr[arr.length-1];
        for(int i=arr.length-1; i > 0; i--){
            int temp = arr[i];
            arr[i] = arr[i-1];
        }
        arr[0] = lastArray;
    } 
   
   
    
    
    
    
    private void printStates(int[][][] states){
        for(int i=0; i < states.length; i++){
            for(int j=0; j < states[i].length; j++){
                for(int k=0; k < states[i][j].length; k++){
                    System.out.print("\t"+states[i][j][k]);
                }System.out.println();
            } System.out.println();
        
        }
        
    } 
    
    
    
    
    
    
    
    
  private static final int[][] sbox = 
    {
    {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
    {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
    {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},
    {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},
    {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},
    {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},
    {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},
    {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},
    {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},
    {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},
    {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},
    {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},
    {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},
    {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},
    {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},
    {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}
    };
    
    private static final int[][] Invsbox = 
    {
        {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},
        {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},
        {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},
        {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},
        {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},
        {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},
        {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},
        {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},
        {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},
        {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},
        {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},
        {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},
        {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},
        {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},
        {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},
        {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}
   };
    
   static int[][] getsbox(){
       return sbox;
   } 
   static int[][] getInvsbox(){
       return Invsbox;
   }    
    
        private static final int[] RCon = 
    {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
    };
    
    static int[] getRCon(){
        return RCon;
    }
    
      private final int[][] MultiplyBy2 = 
      {
      {0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e},
      {0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e},
      {0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e},
      {0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e},
      {0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e},
      {0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe},
      {0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde},
      {0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe},
      {0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05},
      {0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25},
      {0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45},
      {0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65},
      {0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85},
      {0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5},
      {0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5},
      {0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5}
      };  
    
       private final int[][] MultiplyBy3 = 
      {
      {0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11},
      {0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21},
      {0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71},
      {0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41},
      {0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1},
      {0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1},
      {0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1},
      {0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81},
      {0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a},
      {0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba},
      {0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea},
      {0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda},
      {0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a},
      {0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a},
      {0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a},
      {0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a}
      }; 
       
      private final int[][] MultiplyBy9 = 
      {
      {0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77},
      {0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7},
      {0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c},
      {0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc},
      {0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01},
      {0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91},
      {0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a},
      {0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa},
      {0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b},
      {0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b},
      {0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0},
      {0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30},
      {0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed},
      {0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d},
      {0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6},
      {0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46}
      }; 
       
      private final int[][] MultiplyBy11 = 
      {
      {0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69},
      {0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9},
      {0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12},
      {0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2},
      {0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f},
      {0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f},
      {0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4},
      {0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54},
      {0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e},
      {0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e},
      {0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5},
      {0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55},
      {0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68},
      {0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8},
      {0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13},
      {0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3}
      };
      
       private final int[][] MultiplyBy13 = 
      {
      {0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b},
      {0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b},
      {0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0},
      {0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20},
      {0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26},
      {0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6},
      {0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d},
      {0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d},
      {0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91},
      {0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41},
      {0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a},
      {0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa},
      {0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc},
      {0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c},
      {0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47},
      {0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97}
      };
      
       private final int[][] MultiplyBy14 = 
      {
      {0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a},
      {0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba},
      {0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81},
      {0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61},
      {0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7},
      {0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17},
      {0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c},
      {0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc},
      {0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b},
      {0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb},
      {0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0},
      {0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20},
      {0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6},
      {0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56},
      {0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d},
      {0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d}
      }; 
                  
       int Result(int hexa, int multVal){
           int result = 0;
           String hexaDec = Integer.toHexString(hexa);
           switch(multVal){
               default:
               result = hexa;
               break;
               case 2:
               try{    
               result = MultiplyBy2
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]
                       [Integer.parseInt(hexaDec.substring(1,2), 16)];    
               }catch(Exception exc){
               result = MultiplyBy2
                       [0]
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]; 
               }        
               break;
               case 3:
               try{    
               result = MultiplyBy3
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]
                       [Integer.parseInt(hexaDec.substring(1,2), 16)];    
               }catch(Exception exc){
               result = MultiplyBy3
                       [0]
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]; 
               }        
               break;
               case 9:
               try{    
               result = MultiplyBy9
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]
                       [Integer.parseInt(hexaDec.substring(1,2), 16)];    
               }catch(Exception exc){
               result = MultiplyBy9
                       [0]
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]; 
               }        
               break;  
               case 11:
               try{    
               result = MultiplyBy11
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]
                       [Integer.parseInt(hexaDec.substring(1,2), 16)];    
               }catch(Exception exc){
               result = MultiplyBy11
                       [0]
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]; 
               }        
               break;    
               case 13:
               try{    
               result = MultiplyBy13
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]
                       [Integer.parseInt(hexaDec.substring(1,2), 16)];    
               }catch(Exception exc){
               result = MultiplyBy13
                       [0]
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]; 
               }        
               break;
               case 14:
               try{    
               result = MultiplyBy14
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]
                       [Integer.parseInt(hexaDec.substring(1,2), 16)];    
               }catch(Exception exc){
               result = MultiplyBy14
                       [0]
                       [Integer.parseInt(hexaDec.substring(0,1), 16)]; 
               } 
               break;
           }
           
           return result;
       }
    
    
    
    
}